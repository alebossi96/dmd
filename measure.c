
#include "measure.h"

int offset(const int startPosition, const int lineWidth, const int previousPos ){
	return startPosition*lineWidth + previousPos;
}

void initDMD(struct Info info, struct DMD *dmd){

    /* initialization of hidapi library and HID device*/
	hid_init();
	dmd->handle = hid_open(0x0451, 0xc900, NULL);
	sleep(2); // dead time to be sure the device is connected
	if (dmd->handle == NULL) {
		printf("***Error: unable to open device\n");
		dmd->handle = NULL;
		if(!DEBUG){
            printf("Press any key to exit.\n");
            getchar();
            exit(1);
		}
	}
	stopSequence(dmd->handle);
	changeMode(dmd->handle, 3);

    /* setup data needed */
	int RasterOrHadamard = info.RasterOrHadamard;
	int nBasis = info.nBasis;
	int nMeas = info.nMeas;
	int startPosition = info.startPosition;
	int exp = info.exp;
	int dark_time = info.dark_time;
	int repeat = info.repeat;
	int compress = info.compress;
	int sizeBatch = info.sizeBatch;
	int previousPos = info.previousPos;

	int offset_ = offset(startPosition, nBasis, previousPos)/nBasis; // ??
	int nSet = celing(nMeas, sizeBatch);
	//printf("nSet = %d \n", nSet);
	dmd->szPattern = nSet;
	dmd->repeat = repeat;

	int *exposure;
	int *trigger_in;  // if 1 the DMD waits for an external trigger to change pattern
	int *trigger_out; // if 1 the DMD sends a trigger signal when changes the pattern
	unsigned char ***basis;

	/* allocation of memory and insertion of basis data */
	dmd->pattern = (struct Patterns *)malloc(nSet*sizeof(struct Patterns));
	for (int q=0; q<nSet; q++){
		int nEl = min(sizeBatch, nMeas-q*sizeBatch); // it's the number of images in the current batch
		// allocate of memory
		allocatePattern(&(dmd->pattern[q]), nEl);
		exposure = (int *) malloc(nEl * sizeof(int));
		trigger_in = (int *) malloc(nEl * sizeof(int));
		trigger_out = (int *) malloc(nEl * sizeof(int));
		basis = (unsigned char***)malloc(nEl*sizeof(unsigned char**));
		for(int i=0; i<nEl; i++){
            basis[i] = (unsigned char**)malloc(HEIGHT*sizeof(unsigned char*));
		}
		for(int i=0; i<nEl; i++){
			for(int j=0; j<HEIGHT; j++){
                basis[i][j] = (unsigned char*)malloc(WIDTH*sizeof(unsigned char));
			}
		}
		// insert data into pattern
		for (int i=0; i<nEl; i++){
			exposure[i] = exp;
			trigger_out[i] = 1;
			trigger_in[i] = 0;
        }
		int nB; // nB contiene le info su quante info vere ci sono, # di basi caricate (nB non assume lo stesso valore di nEl?)
		if(nMeas > (q+1)*sizeBatch)
			nB = sizeBatch;
		else
			nB = nMeas - q*sizeBatch;
		int *idx;
		idx = (int* )malloc((nB)*sizeof(int)); // index of the first element inside the batch
		for(int i=0; i<nB; i++)
			idx[i] = q*sizeBatch + i + offset_;
		getBasis(RasterOrHadamard, nBasis, idx, nB, compress, basis); // generation of pattern
		free(idx);
		printf("\n");
		for (int k=0; k<nEl; k++){
			for(int i=0; i<WIDTH; i+=100)
				printf("%d ", basis[k][0][i]);
            printf("\n");
		}
		printf("\n");

		dmd->pattern[q].nB = nB;
		int numberOfRepetition;
		if(repeat)
			numberOfRepetition = 0;
		else
			numberOfRepetition = nEl; // the number can be as large as 500!
		defSequence(&(dmd->pattern[q]), basis, exposure, trigger_in, dark_time, trigger_out, numberOfRepetition, nEl); // il penultimo o 1 o nEl1
		for(int i=0; i<nEl; i++){
			for(int j=0; j<HEIGHT; j++)
                free(basis[i][j]);
            free(basis[i]);
		}
		free(basis);
		free(exposure);
		free(trigger_out);
		free(trigger_in);
	}
}

void moveDMD(const struct DMD dmd){

	// All data needed to move the DMD is generated by defSequence and saved in dmd.pattern

	for(int i=0; i<dmd.szPattern; i++){
		stopSequence(dmd.handle);
		printf("Uploading pattern (%d of %d)\n", i+1, dmd.szPattern);
		int totExposure = 0;

		for(int j=0; j<dmd.pattern[i].nEl; j++){
			totExposure += dmd.pattern[i].exposure[j];
			// define the pattern
			printf("Uploading pattern definitions (%d of %d)\n", j+1, dmd.pattern[i].nEl);
			talkDMD_char(dmd.handle, 'w', 0x00, 0x1a, 0x34, dmd.pattern[i].defPatterns[j], 12);
			if(!DEBUG)
                checkForErrors(dmd.handle);
        }
        // configure LUT
        printf("Uploading LUT\n");
		talkDMD_char(dmd.handle, 'w', 0x00, 0x1a, 0x31, dmd.pattern[i].configureLut, 6);
		if(!DEBUG)
            checkForErrors(dmd.handle);
		// setBmp
		for(int k = dmd.pattern[i].numOfBatches-1; k>=0; k--){
            printf("Uploading batch %d of %d\n", dmd.pattern[i].numOfBatches-k, dmd.pattern[i].numOfBatches);
            talkDMD_char(dmd.handle, 'w', 0x00, 0x1a, 0x2a, dmd.pattern[i].setBmp[k], 6);
			if(!DEBUG)
                checkForErrors(dmd.handle);
			// bmpLoad
			for(int j=0; j<dmd.pattern[i].packNum[k]; j++){
				talkDMD_char(dmd.handle, 'w', 0x11, 0x1a, 0x2b, dmd.pattern[i].bmpLoad[k][j], dmd.pattern[i].bitsPackNum[k][j]);
			}
			if(!DEBUG){
                checkForErrors(dmd.handle);
                //checkErrorMessage(dmd.handle); // TEST
            }
		}
        printf(">> Press ENTER to start pattern . . .");
		getchar();
		startSequence(dmd.handle);
		int tDead = 0; //0.5 s of dead time
		int tSleep = totExposure/1e6-tDead + 1;
		printf("totExposure = %d\n", totExposure);
		if(totExposure/1e6-tDead<0)
            tSleep = 0;
		if(dmd.repeat){
			printf(">> Press ENTER to continue . . .");
            getchar();
		}
		else
			sleep(tSleep+1);
        printf("\n");
			//need to wait for the pattern to finish
            //sleep must be in input a number >0.001
		//TODO:nel TRS quando ho finito di ricevere tutti i trigger
	}
}

void closeDMD(struct DMD* dmd){

    // free memory
	for (int q = 0; q < dmd->szPattern; q++){
		free(dmd->pattern[q].defPatterns);
		for(int k = 0; k<dmd->pattern[q].numOfBatches; k++){
			for(int i = 0; i<dmd->pattern[q].packNum[k]; i++){
				free(dmd->pattern[q].bmpLoad[k][i]);
			}
			free(dmd->pattern[q].bmpLoad[k]);
			free(dmd->pattern[q].bitsPackNum[k]);
		}
		free(dmd->pattern[q].bmpLoad);
		free(dmd->pattern[q].bitsPackNum);
		free(dmd->pattern[q].setBmp);
		free(dmd->pattern[q].packNum);
		free(dmd->pattern[q].exposure);
	}
	free(dmd->pattern);

	// close communication with DMD
	hid_close(dmd->handle);
	hid_exit();
}

int talkDMD_int(hid_device *handle, const char mode, const char sequencebyte, const char com1, const char com2, const int *data, const int sizeData){
	unsigned char *tmp;
	tmp = (unsigned char *)malloc(sizeData*sizeof(unsigned char));
	for(int i=0; i<sizeData; i++)
		tmp[i] = (unsigned char)data[i];

	int res = talkDMD_char(handle, mode, sequencebyte, com1, com2, tmp, sizeData);

	free(tmp);
	return res;
}

int talkDMD_char(hid_device *handle, const char mode, const char sequencebyte, const char com1, const char com2, const unsigned char *data, const int sizeData){

	unsigned char buffer[SIZE_SEND];
	char flagstring[8];
	int res;

    // Flag Byte (says read or write in the buffer)
	if(mode == 'r')
		flagstring[0] = '1'; // 11000000 -> 0xC0
	else
		flagstring[0] = '0'; // 01000000 -> 0x80
	flagstring[1] = '1';
	for(int i=2; i<8; i++)
		flagstring[i] = '0';
	buffer[0] = 0x00;
	int *tmp = bitsToBytes(flagstring, 8);
	buffer[1] = tmp[0];
	free(tmp);

	// Sequence byte
	buffer[2] = sequencebyte;

	// Length
	char *tmpChar;
	tmpChar = convlen(sizeData+2, 16);
	tmp = bitsToBytes(tmpChar, 16);
	buffer[3] = tmp[0]; // LSB
	buffer[4] = tmp[1]; // MSB
	free(tmp);
	free(tmpChar);

	// USB Commands
	buffer[5] = com2;
	buffer[6] = com1;

	long int tot = 7; // bytes used for commands
	int j = 0;

	// this is the case of a read command
	if(data == NULL){
        res = hid_write(handle, buffer, 7);
        return 0;
	}

	// attach data in the buffer
	if((tot+sizeData)<SIZE_SEND){
        // data fit the buffer: load to DMD
		for(int i=0; i<sizeData; i++)
            buffer[tot+i] = data[i];
		for(int i=tot+sizeData; i<SIZE_SEND; i++)           // se il pacchetto finisce prima perchè devo riempirlo di 0? Posso interromperlo e inviare meno di 65 bytes al dmd
            buffer[i] = 0x00;
		if(!DEBUG){
			res = hid_write(handle, buffer, SIZE_SEND);
			// printf("written bytes = %d \n", res);
		}
		else{
            if(PRINT_BYTES){
                for(int k=0; k<SIZE_SEND; k++)
                    printf("%d, ", buffer[k]);
                printf("\n\n");
			}
			else
                writeOnFile("cCommand.txt", buffer, SIZE_SEND);
		}
	}
	else{
        // data exceed buffer size: load in many times (only the first time needs the header + commands)
		for(int i=0; i<SIZE_SEND-tot; i++)
            buffer[i+tot] = data[i];
		if(!DEBUG){
			res = hid_write(handle, buffer, SIZE_SEND);
			// printf("written bytes = %d \n", res);
		}
		else{
            if(PRINT_BYTES){
                for(int k=0; k<SIZE_SEND; k++)
                    printf("%d, ", buffer[k]);
                printf("\n\n");
            }
			else
                writeOnFile("cCommand.txt", buffer, SIZE_SEND);
		}
		for(int i=0; i<SIZE_SEND; i++)
            buffer[i] = 0;
		int i = 1;
		j = SIZE_SEND-tot;
		while(j<sizeData){
			buffer[i] = data[j];
			j++;
			i++;
			if(i%SIZE_SEND == 0){
				if(!DEBUG){
                    res = hid_write(handle, buffer, SIZE_SEND);
                    // printf("written bytes = %d \n", res);
				}
				else{
				    if(PRINT_BYTES){
                        for(int k=0; k<SIZE_SEND; k++)
                            printf("%d, ", buffer[k]);
                        printf("\n\n");
				    }
					else
                        writeOnFile("cCommand.txt", buffer, SIZE_SEND);
				}
                i = 1;
			}
		}
		if(i%SIZE_SEND !=0 && i != 1){
			while(i%SIZE_SEND!=0){
				buffer[i] = 0x00;
				j++;
				i++;
            }
			if(!DEBUG){
				res = hid_write(handle, buffer, SIZE_SEND);
				// printf("written bytes = %d \n", res);
			}
			else{
                if(PRINT_BYTES){
                    for(int k = 0; k<SIZE_SEND;k++)
                        printf("%d, ", buffer[k]);
                    printf("\n\n");
                }
				else
                    writeOnFile("cCommand.txt", buffer, SIZE_SEND);
			}
		}
	}
	//if(!DEBUG)
	//	checkForErrors(handle);
	//fclose(pFile);
    return 0;
}

void changeMode(hid_device *handle, int mode_){
	unsigned char mode[1];
	mode[0] = mode_;
	printf("DMD Mode changed to %d\n", mode_);
	talkDMD_char(handle, 'w', 0x00, 0x1a, 0x1b, mode, 1);
}

void stopSequence(hid_device *handle){
	unsigned char mode[1] = {0};
	printf("DMD Stop Sequence\n");
	talkDMD_char(handle, 'w', 0x00, 0x1a, 0x24, mode, 1);
}

void startSequence(hid_device *handle){
	unsigned char mode[1] = {2};
	printf("DMD Start Sequence\n");
	talkDMD_char(handle, 'w', 0x00, 0x1a, 0x24, mode, 1);
}

void reset(hid_device *handle){
	unsigned char mode[1] = {2};
	printf("DMD Reset\n");
	talkDMD_char(handle, 'w', 0x00, 0x02, 0x00, mode, 1);
}

void checkForErrors(hid_device *handle){

    // not working correctly (sometimes reads the previous command from buffer instead of the response of the dmd to the check error command)

	unsigned char message[5];
	//sleep(5);
	talkDMD_char(handle, 'r', 0x11, 0x01, 0x00, NULL, 0);
	//sleep(1);
	int res = hid_read(handle, message, 5);
	//printf("read bytes: %d\n", res);
	if(res == -1)
        printf("***HIDAPI ERROR\n");
        /*
    if(message[1] != 0xC0)
        printf("***DMD: Command not found or command failed\n");
    if(message[2] == 0x11)
        printf("Sequence byte mateches\n");
    else
        printf("Sequence byte NOT match\n");
    if(message[5] != 0)
        printf("***DMD ERROR CODE %d\n", message[5]);
        */
        /*
        for(int i=0; i<5; i++)
            printf("%d,", message[i]);
        printf("\n");
        */

}

void checkErrorMessage(hid_device *handle){

    unsigned char message1[64];
    unsigned char message2[64];
    unsigned char message[128];
    int res = 0;
    talkDMD_char(handle, 'r', 0x11, 0x01, 0x01, NULL, 0);
    //sleep(5);
    res = hid_read(handle, message1, 64);
    res = hid_read(handle, message2, 64);
    for(int i=0; i<128; i++){
        if(i<64)
            message[i] = message1[i];
        else
            message[i] = message[i-64];
    }
    printf("%s", message);
    printf("\n");

}


