
#include "measure.h"

int offset(const int startPosition, const int lineWidth, const int previousPos ){
	return startPosition*lineWidth + previousPos;
}

void initDMD(struct Info info, struct DMD *dmd){

    /* initialization of hidapi library and HID device*/
	hid_init();
	dmd->handle = hid_open(0x0451, 0xc900, NULL);
	sleep(2); // dead time to be sure the device is connected
	if (dmd->handle == NULL) {
		printf("***Error: unable to open device\n");
		dmd->handle = NULL;
		if(!DEBUG){
            printf("Press any key to exit.\n");
            getchar();
            exit(1);
		}
	}
	stopSequence(dmd->handle);
	changeMode(dmd->handle, 3);

    /* setup data needed */
	int RasterOrHadamard = info.RasterOrHadamard;
	int nBasis = info.nBasis;
	int nMeas = info.nMeas;
	int startPosition = info.startPosition;
	int exp = info.exp;
	int dark_time = info.dark_time;
	int repeat = info.repeat;
	int compress = info.compress;
	int sizeBatch = info.sizeBatch;
	int previousPos = info.previousPos;
	int zoom = info.zoom;
	int xCenter = info.xC;
	int yCenter = info.yC;

	int offset_ = offset(startPosition, nBasis, previousPos)/nBasis; // ??
	int nSet = celing(nMeas, sizeBatch);
	//printf("nSet = %d \n", nSet);
	dmd->szPattern = nSet;
	dmd->repeat = repeat;

	int *exposure;
	int *trigger_in;  // if 1 the DMD waits for an external trigger to change pattern
	int *trigger_out; // if 1 the DMD sends a trigger signal when changes the pattern
	unsigned char ***basis;

	/* allocation of memory and insertion of basis data */
	dmd->pattern = (struct Patterns *)malloc(nSet*sizeof(struct Patterns));
	for (int q=0; q<nSet; q++){
		int nEl = min(sizeBatch, nMeas-q*sizeBatch); // it's the number of images in the current batch
		// allocate of memory
		allocatePattern(&(dmd->pattern[q]), nEl);
		exposure = (int *) malloc(nEl * sizeof(int));
		trigger_in = (int *) malloc(nEl * sizeof(int));
		trigger_out = (int *) malloc(nEl * sizeof(int));
		basis = (unsigned char***)malloc(nEl*sizeof(unsigned char**));
		for(int i=0; i<nEl; i++){
            basis[i] = (unsigned char**)malloc(HEIGHT*sizeof(unsigned char*));
		}
		for(int i=0; i<nEl; i++){
			for(int j=0; j<HEIGHT; j++){
                basis[i][j] = (unsigned char*)malloc(WIDTH*sizeof(unsigned char));
			}
		}
		// initialize basis
		for(int i=0; i<nEl; i++){
            for(int j=0; j<HEIGHT; j++){
                for(int k=0; k<WIDTH; k++){
                    basis[i][j][k] = 0;
                }
            }
		}
		// insert data into pattern
		for (int i=0; i<nEl; i++){
			exposure[i] = exp;
			trigger_out[i] = 1;
			trigger_in[i] = 0;
        }
		int nB; // nB contiene le info su quante info vere ci sono, # di basi caricate (nB non assume lo stesso valore di nEl?)
		if(nMeas > (q+1)*sizeBatch)
			nB = sizeBatch;
		else
			nB = nMeas - q*sizeBatch;
		int *idx;
		idx = (int* )malloc((nB)*sizeof(int)); // index of the first element inside the batch
		for(int i=0; i<nB; i++)
			idx[i] = q*sizeBatch + i + offset_;
		getBasis(RasterOrHadamard, nBasis, idx, nB, compress, zoom, xCenter, yCenter, basis); // generation of pattern
		free(idx);
		printf("\n");
		for (int k=0; k<nEl; k++){
			for(int i=0; i<WIDTH; i+=100)
				printf("%d ", basis[k][0][i]);
            printf("\n");
		}
		printf("\n");

		// print bases on txt file
		if(DMD_SIMULATOR) writePatternsOnFile(nEl, basis);

		dmd->pattern[q].nB = nB;
		int numberOfRepetition;
		if(repeat)
			numberOfRepetition = 0;
		else
			numberOfRepetition = nEl; // the number can be as large as 500!
		defSequence(&(dmd->pattern[q]), basis, exposure, trigger_in, dark_time, trigger_out, numberOfRepetition, nEl); // il penultimo o 1 o nEl1
		for(int i=0; i<nEl; i++){
			for(int j=0; j<HEIGHT; j++)
                free(basis[i][j]);
            free(basis[i]);
		}
		free(basis);
		free(exposure);
		free(trigger_out);
		free(trigger_in);
	}
}

void moveDMD(const struct DMD dmd){

	// All data needed to move the DMD is generated by defSequence and saved in dmd.pattern

	for(int i=0; i<dmd.szPattern; i++){
		stopSequence(dmd.handle);
		printf("Uploading pattern (%d of %d)\n", i+1, dmd.szPattern);
		int totExposure = 0;

		for(int j=0; j<dmd.pattern[i].nEl; j++){
			totExposure += dmd.pattern[i].exposure[j];
			// define the pattern
			printf("Uploading pattern definitions (%d of %d)\n", j+1, dmd.pattern[i].nEl);
			talkDMD_char(dmd.handle, 'w', 0x00, 0x1a, 0x34, dmd.pattern[i].defPatterns[j], 12);
			if(!DEBUG)
                checkForErrors(dmd.handle);
        }
        // configure LUT
        printf("Uploading LUT\n");
		talkDMD_char(dmd.handle, 'w', 0x00, 0x1a, 0x31, dmd.pattern[i].configureLut, 6);
		if(!DEBUG)
            checkForErrors(dmd.handle);
		// setBmp
		for(int k = dmd.pattern[i].numOfBatches-1; k>=0; k--){
            printf("Uploading batch %d of %d\n", dmd.pattern[i].numOfBatches-k, dmd.pattern[i].numOfBatches);
            talkDMD_char(dmd.handle, 'w', 0x00, 0x1a, 0x2a, dmd.pattern[i].setBmp[k], 6);
			if(!DEBUG)
                checkForErrors(dmd.handle);
			// bmpLoad
			for(int j=0; j<dmd.pattern[i].packNum[k]; j++){
				talkDMD_char(dmd.handle, 'w', 0x11, 0x1a, 0x2b, dmd.pattern[i].bmpLoad[k][j], dmd.pattern[i].bitsPackNum[k][j]);
			}
			if(!DEBUG){
                checkForErrors(dmd.handle);
                //checkErrorMessage(dmd.handle); // TEST
            }
		}
        printf(">> Press ENTER to start pattern . . .");
		getchar();
		startSequence(dmd.handle);
		int tDead = 0; //0.5 s of dead time
		int tSleep = totExposure/1e6-tDead + 1;
		printf("totExposure = %d\n", totExposure);
		if(totExposure/1e6-tDead<0)
            tSleep = 0;
		if(dmd.repeat){
			printf(">> Press ENTER to continue . . .");
            getchar();
		}
		else
			sleep(tSleep+1);
        printf("\n");
			//need to wait for the pattern to finish
            //sleep must be in input a number >0.001
		//TODO:nel TRS quando ho finito di ricevere tutti i trigger
	}
}

void closeDMD(struct DMD* dmd){

    // free memory
	for (int q = 0; q < dmd->szPattern; q++){
		free(dmd->pattern[q].defPatterns);
		for(int k = 0; k<dmd->pattern[q].numOfBatches; k++){
			for(int i = 0; i<dmd->pattern[q].packNum[k]; i++){
				free(dmd->pattern[q].bmpLoad[k][i]);
			}
			free(dmd->pattern[q].bmpLoad[k]);
			free(dmd->pattern[q].bitsPackNum[k]);
		}
		free(dmd->pattern[q].bmpLoad);
		free(dmd->pattern[q].bitsPackNum);
		free(dmd->pattern[q].setBmp);
		free(dmd->pattern[q].packNum);
		free(dmd->pattern[q].exposure);
	}
	free(dmd->pattern);

	// close communication with DMD
	hid_close(dmd->handle);
	hid_exit();
}

void writePatternsOnFile(const int nEl, unsigned char ***basis){
    for(int f=0; f<nEl; f++){
        char name[] = "b000.txt";
        if (f<10){
        }
        else if(f<100){
        }
        else if(f<1000){
        }
        //printf("FileName %s\n", name);
        FILE *tmpF = fopen(name, "w");
        for(int j=0; j<HEIGHT; j++){
            for(int i=0; i<WIDTH; i++){
                if(i == WIDTH-1) fprintf(tmpF, "%d", basis[f][j][i]);
                else fprintf(tmpF, "%d,", basis[f][j][i]);
            }
        fprintf(tmpF, "\n");
        }
        fclose(tmpF);
    }
}


